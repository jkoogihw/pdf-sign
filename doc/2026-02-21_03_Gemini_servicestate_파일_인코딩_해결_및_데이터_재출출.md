# 2026-02-21_03_Gemini_servicestate_파일_인코딩_해결_및_데이터_재출출.md

## 1. 문제 현상
- `servicestate.txt` 파일 내의 한글 텍스트가 깨져서 표시됨 (예: `?버 ?션` 등).
- 파일이 윈도우 기본 인코딩(CP949)으로 작성되었으나, 에디터나 도구에서 UTF-8 등으로 잘못 해석하면서 텍스트 유실 및 인코딩 충돌 발생.

## 2. 원인 분석
- **인코딩 불일치**: `netsh http show servicestate` 명령의 결과는 윈도우 시스템 코드페이지(주로 CP949)를 따름.
- **PowerShell 파이프라인 이슈**: PowerShell의 `>` 또는 `Out-File` 명령은 기본적으로 UTF-16LE 또는 특정 인코딩으로 파일을 생성하는데, 이 과정에서 원본 시스템 출력과 부딪히며 데이터가 깨질 수 있음.
- **복구 불가능한 유실**: 이미 인코딩이 꼬인 상태에서 여러 번 변환을 시도하면 본래의 바이트 정보가 유실되어 복구가 어려워짐.

## 3. 조치 내용 (해결 과정)

### 3.1. 초기 시도 (변환 시도)
- PowerShell의 `Get-Content`와 `Out-File`을 사용하여 인코딩 명시적 변환 시도 (`Unicode`, `Default`, `UTF8` 등).
- 결과: 이미 꼬여버린 데이터를 내부적으로 복구하지 못해 여전히 깨진 상태 유지.

### 3.2. 최종 해결책 (데이터 재추출)
가장 확실한 방법인 **"원본 데이터를 올바른 인코딩으로 처음부터 다시 추출"**하는 방식을 채택함.

1.  **코드페이지 명시**: 출력 인코딩이 꼬이지 않도록 출력 코드페이지를 미리 설정하거나 .NET 메서드를 직접 활용.
2.  **직접 재기록 (최종 해결 명령어)**:
    PowerShell 파이프라인의 인코딩 간섭을 피하기 위해 `.NET` 메서드를 직접 사용하여 데이터를 캡처하고 저장함.
    ```powershell
    # 파일 경로 설정
    $path = "servicestate.txt"

    # netsh의 출력 결과를 변수에 담기 (개행 처리 보존)
    $content = & netsh http show servicestate

    # UTF-8(BOM 없음)으로 인코딩을 지정하여 파일 쓰기
    [System.IO.File]::WriteAllLines($path, $content, [System.Text.Encoding]::UTF8)
    ```
- 이를 통해 시스템 명령어의 출력 결과물로부터 직접 UTF-8 파일을 생성하여 인코딩 충돌을 원천 차단함.

## 4. 결과
- `servicestate.txt` 파일의 내용이 깨짐 없이 정상적으로 표시됨.
- 에디터 및 외부 도구에서 별도의 설정 없이도 한글/영문 텍스트를 모두 올바르게 읽을 수 있게 됨.
